#include <Pack/RPAudio.h>

#include <egg/audio.h>
#include <egg/core.h>

#include <nw4r/snd.h>

#include <revolution/WPAD.h>

// generated by dtk
#include <Pack/RPAudio/rp_Static_sound.brsar.inc>

/**
 * @brief Constructor
 */
RPSndStaticMgr::RPSndStaticMgr() : ArcPlayer(NULL) {
    for (int i = 0; i < WPAD_MAX_CONTROLLERS; i++) {
        mStartTasks[i].valid = false;
    }
}

/**
 * @brief Destructor
 */
RPSndStaticMgr::~RPSndStaticMgr() {}

/**
 * @brief Mounts the static sound archive
 *
 * @return Success
 */
bool RPSndStaticMgr::setupArchive() {
    mSoundHeap = &RP_GET_INSTANCE(RPSndAudioMgr)->getSoundHeap();

    bool success = setupMemoryArchive(
                       sStaticSoundArchive,
                       &RP_GET_INSTANCE(RPSndAudioMgr)->getSoundHeap()) != NULL;

    return success;
}

/**
 * @brief Updates the state of the sound player
 */
void RPSndStaticMgr::calc() {
    for (int i = 0; i < WPAD_MAX_CONTROLLERS; i++) {
        StartTask& rTask = mStartTasks[i];
        if (!rTask.valid) {
            continue;
        }

        if (!nw4r::snd::SoundSystem::GetRemoteSpeaker(i).IsEnabledOutput()) {
            if (--rTask.timeOut == 0) {
                rTask.valid = false;
            }

            continue;
        }

        getPlayer().StartSound(&mSoundHandle, rTask.id);
        setRemoteSend(rTask.playerFlag);

        rTask.valid = false;
    }

    ArcPlayer::calc();
}

/**
 * @brief Starts a sound effect through the main output and the specified
 * player's remote output
 *
 * @param id Sound effect ID
 * @param player Player index
 */
void RPSndStaticMgr::startSe(u32 id, s32 player) {
    s32 chan = EGG_GET_INSTANCE(EGG::CoreControllerMgr)
                   ->getNthController(player)
                   ->getChannelID();

    u32 playerFlag = 1 << player;

    if (nw4r::snd::SoundSystem::GetRemoteSpeaker(chan).IsAvailable()) {
        getPlayer().StartSound(&mSoundHandle, id);
        setRemoteSend(playerFlag);
    } else {
        mStartTasks[chan].valid = true;
        mStartTasks[chan].timeOut = TIMEOUT;
        mStartTasks[chan].id = id;
        mStartTasks[chan].playerFlag = playerFlag;
        mStartTasks[chan].unkC = 60;
        mStartTasks[chan].unk4 = 0;
    }
}

/**
 * @brief Configures the main and remote output volumes for the specified
 * sound
 *
 * @param playerFlag Player output line flags
 */
void RPSndStaticMgr::setRemoteSend(u32 playerFlag) {
    if (!mSoundHandle.IsAttachedSound()) {
        return;
    }

    u32 param = getSoundArchive().GetSoundUserParam(mSoundHandle.GetId());
    if (!(param & 0xFFFF0000)) {
        return;
    }

    // clang-format off
    f32 mainOut =   static_cast<f32>(param >> 16 & 0x7F) / WPAD_MAX_SPEAKER_VOLUME;
    f32 muteOut =   static_cast<f32>(param >> 8  & 0x7F) / WPAD_MAX_SPEAKER_VOLUME;
    f32 remoteOut = static_cast<f32>(param >> 24)        / WPAD_MAX_SPEAKER_VOLUME;
    // clang-format on

    RP_GET_INSTANCE(RPSndSpeakerMgr)
        ->setRemoteSend(&mSoundHandle, playerFlag, mainOut, remoteOut, muteOut);
}
